<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ぺたんのことばタイピング</title>
    <style>
        body {
            background-color: #f5f5dc; /* 淡いベージュ */
            font-family: 'Hiragino Sans', 'ヒラギノ角ゴシック', 'メイリオ', Meiryo, 'MS Pゴシック', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            color: #5d4037;
        }

        .container {
            text-align: center;
            padding: 20px;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 600px;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 20px;
        }

        .game-area {
            position: relative;
        }

        #petan-img {
            width: 150px;
            height: auto;
            margin-top: 20px;
            transition: transform 0.2s;
        }

        /* ぺたんのリアクション用アニメーション */
        .shake {
            animation: shake 0.5s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px) rotate(-5deg); }
            75% { transform: translateX(10px) rotate(5deg); }
        }

        .happy {
             animation: happy 0.5s;
        }
        @keyframes happy {
            0%, 100% { transform: scale(1) rotate(0); }
            50% { transform: scale(1.1) rotate(5deg); }
        }
        
        .speech-bubble {
            position: relative;
            background: #e8eaf6;
            border-radius: .4em;
            padding: 15px;
            min-height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .speech-bubble:after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 0;
            height: 0;
            border: 20px solid transparent;
            border-top-color: #e8eaf6;
            border-bottom: 0;
            margin-left: -20px;
            margin-bottom: -20px;
        }

        #romaji-display {
            font-size: 22px;
            font-family: monospace;
            letter-spacing: 2px;
            color: #888;
            height: 30px;
        }
        #romaji-display .typed {
            color: #388e3c; /* 濃い緑 */
        }

        #input-box {
            width: 80%;
            padding: 10px;
            font-size: 18px;
            border: 2px solid #ccc;
            border-radius: 5px;
            text-align: center;
            margin-top: 20px;
        }
        #input-box:focus {
            outline: none;
            border-color: #a5d6a7;
        }

        .clear-screen {
            display: none; /* 初期状態では非表示 */
            flex-direction: column;
            align-items: center;
        }
        
        .clear-screen h2 {
            font-size: 28px;
            color: #ff6f61;
        }

        .clear-animation {
            animation: clear-anim 1.5s ease-in-out infinite;
        }
        @keyframes clear-anim {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-15px) scale(1.1); }
        }

        #start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        #start-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #a5d6a7; /* 緑系 */
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 30px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: background-color 0.3s;
        }

        #start-button:hover {
            background-color: #81c784;
        }

    </style>
</head>
<body>

    <div class="container">
        <h1>ぺたんのことばタイピング</h1>

        <div id="start-screen">
            <img src="petan.png" alt="ぺたん" style="width: 180px; margin-bottom: 20px;">
            <p style="font-size: 18px;">ぺたんと一緒にタイピングを始めよう！</p>
            <button id="start-button">ゲームスタート</button>
        </div>

        <div id="game-container" style="display: none;">
            <div style="display: flex; justify-content: space-between; font-size: 20px; margin-bottom: 15px; padding: 0 20px;">
                <div id="score">スコア: 0</div>
                <div id="timer">残り時間: 60</div>
            </div>
            <div class="speech-bubble">
                <p id="sentence">ここにセリフがでるよ</p>
            </div>
            <div id="romaji-display"></div>
            <div class="game-area">
                <img src="petan.png" alt="ぺたん" id="petan-img">
            </div>
            <input type="text" id="input-box" placeholder="ローマ字で入力してね" autocomplete="off" autofocus>
        </div>

        <div id="end-screen" class="clear-screen">
            <h2>ゲーム終了！</h2>
            <p id="final-score" style="font-size: 24px; font-weight: bold;"></p>
            <img src="petan.png" alt="ぺたん" style="width: 150px; margin-top: 20px;">
            <p>また挑戦してね！</p>
            <button id="retry-button" style="padding: 10px 20px; font-size: 18px; background-color: #a5d6a7; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px;">もう一度プレイ</button>
        </div>
    </div>

    <script>
        const sentences = [
            { kana: "おやつたべたい", romaji: "oyatsutabetai" },
            { kana: "すやあ", romaji: "suyaa" },
            { kana: "がんばらなくていいよ", romaji: "ganbaranakuteiiyo" },
            { kana: "ぺたんいまからねるね", romaji: "petanimakaranerune" },
            { kana: "なんでもないひばんざい", romaji: "nandemonaihibanzai" }
        ];

        let currentSentence = {};
        let remainingSentences = [...sentences];
        let score = 0;
        let timeLeft = 60;
        let timerId;

        // Web Audio API のコンテキストとバッファ
        let audioContext;
        let correctSoundBuffer;
        let incorrectSoundBuffer;
        let clearSoundBuffer;

        const sentenceElement = document.getElementById('sentence');
        const romajiDisplay = document.getElementById('romaji-display');
        const inputBox = document.getElementById('input-box');
        const petanImg = document.getElementById('petan-img');
        const gameContainer = document.getElementById('game-container');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const endScreen = document.getElementById('end-screen');
        const retryButton = document.getElementById('retry-button');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const finalScoreElement = document.getElementById('final-score');

        // サウンドファイルを読み込む関数
        async function loadSound(url) {
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                return await audioContext.decodeAudioData(arrayBuffer);
            } catch (error) {
                console.error(`サウンドファイルの読み込みに失敗しました: ${url}`, error);
                return null; // 読み込み失敗時はnullを返す
            }
        }

        // サウンドを再生する関数
        function playSound(buffer) {
            if (!buffer) return; // バッファがなければ再生しない
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start(0);
        }

        // ビープ音を生成する関数
        function createBeepSound(frequency = 440, duration = 0.05) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            gainNode.gain.setValueAtTime(1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);

            // バッファとして返すために、一時的なAudioBufferSourceNodeを作成
            const arrayBuffer = audioContext.createBuffer(1, audioContext.sampleRate * duration, audioContext.sampleRate);
            const data = arrayBuffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
                data[i] = Math.sin(i / (audioContext.sampleRate / (frequency * 2 * Math.PI)));
            }
            return arrayBuffer; // バッファを返す
        }

        function startGame() {
            score = 0;
            timeLeft = 60;
            scoreElement.textContent = `スコア: ${score}`;
            timerElement.textContent = `残り時間: ${timeLeft}`;
            lastCorrectValue = '';

            startScreen.style.display = 'none';
            endScreen.style.display = 'none';
            gameContainer.style.display = 'block';
            
            setNextSentence();
            inputBox.focus();

            clearInterval(timerId);
            timerId = setInterval(() => {
                timeLeft--;
                timerElement.textContent = `残り時間: ${timeLeft}`;
                if (timeLeft <= 0) {
                    clearInterval(timerId);
                    endGame();
                }
            }, 1000);
        }

        function setNextSentence() {
            if (remainingSentences.length === 0) {
                remainingSentences = [...sentences];
            }

            const randomIndex = Math.floor(Math.random() * remainingSentences.length);
            currentSentence = remainingSentences.splice(randomIndex, 1)[0];
            
            sentenceElement.textContent = currentSentence.kana;
            romajiDisplay.innerHTML = `<span class="untyped">${currentSentence.romaji}</span>`;
            inputBox.value = '';
            lastCorrectValue = ''; // リセット
            inputBox.style.backgroundColor = 'white';
            inputBox.focus();
        }

        function endGame() {
            gameContainer.style.display = 'none';
            endScreen.style.display = 'flex';
            finalScoreElement.textContent = `最終スコア: ${score}`;
            playSound(clearSoundBuffer); // ゲーム終了音を再生
        }

        function react(type) {
            petanImg.classList.remove('shake', 'happy');
            setTimeout(() => {
                petanImg.classList.add(type);
            }, 10);
            
            setTimeout(() => {
                petanImg.classList.remove(type);
            }, 500);
        }

        /**
         * 入力が正しいかチェックし、ローマ字のどこまでマッチしたかを返す
         * @param {string} typed - 入力されたテキスト
         * @param {string} target - 正解のローマ字
         * @returns {{isCorrect: boolean, matchedLength: number}}
         */
        function checkInput(typed, target) {
            let typedIndex = 0;
            let targetIndex = 0;

            while (typedIndex < typed.length) {
                if (targetIndex >= target.length) {
                    return { isCorrect: false, matchedLength: targetIndex };
                }

                // Rule for "つ": "tu" can be typed for "tsu"
                if (target.startsWith('tsu', targetIndex) && typed.startsWith('tu', typedIndex)) {
                    typedIndex += 2;
                    targetIndex += 3;
                    continue;
                }

                // Rule for "ん": "nn" can be typed for "n"
                if (target.startsWith('n', targetIndex) && typed.startsWith('nn', typedIndex)) {
                    const nextTargetChar = target[targetIndex + 1];
                    // Check if 'n' is 'ん' (not part of な,に,ぬ,ね,の)
                    if (nextTargetChar === undefined || !'aiueoy'.includes(nextTargetChar)) {
                        typedIndex += 2;
                        targetIndex += 1;
                        continue;
                    }
                }

                // Default character comparison
                if (typed[typedIndex] !== target[targetIndex]) {
                    return { isCorrect: false, matchedLength: targetIndex };
                }

                typedIndex++;
                targetIndex++;
            }

            return { isCorrect: true, matchedLength: targetIndex };
        }

        inputBox.addEventListener('input', () => {
            const typedText = inputBox.value.toLowerCase();
            const targetRomaji = currentSentence.romaji;

            const result = checkInput(typedText, targetRomaji);

            if (result.isCorrect) {
                // 正しい文字が入力されたら効果音を鳴らす
                // inputイベントで鳴らすことで、nnやtuの判定後にも鳴るようにする
                playSound(correctSoundBuffer);

                lastCorrectValue = typedText; // 正しい状態を更新
                inputBox.style.backgroundColor = 'white';
                
                const typedPart = targetRomaji.slice(0, result.matchedLength);
                const remainingPart = targetRomaji.slice(result.matchedLength);
                romajiDisplay.innerHTML = `<span class="typed">${typedPart}</span><span class="untyped">${remainingPart}</span>`;

                if (result.matchedLength === targetRomaji.length) {
                    // 正解（文章全体が入力完了）
                    score++;
                    scoreElement.textContent = `スコア: ${score}`;
                    react('happy');
                    inputBox.style.backgroundColor = '#d4edda';
                    setTimeout(() => {
                        setNextSentence();
                    }, 300);
                }
            } else {
                // ミス
                playSound(incorrectSoundBuffer); // 不正解音を再生
                react('shake');
                inputBox.style.backgroundColor = '#f8d7da';
                inputBox.value = lastCorrectValue;
            }
        });

        inputBox.addEventListener('keydown', (e) => {
            if (e.key === 'Backspace' || e.key === 'Delete') {
                e.preventDefault();
            }
            // IME入力中はinputイベントで処理するため、keydownでは効果音を鳴らさない
        });

        // ゲーム開始処理
        startButton.addEventListener('click', async () => {
            // ユーザー操作をトリガーにAudioContextを初期化
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // サウンドファイルを読み込み
            // 読み込み失敗してもゲームは続行できるようにする
            correctSoundBuffer = createBeepSound(); // ビープ音を生成
            incorrectSoundBuffer = createBeepSound(220); // 不正解音をビープ音で生成 (低い音)
            clearSoundBuffer = await loadSound('clear.mp3');

            startGame();
        });

        retryButton.addEventListener('click', startGame);

    </script>

</body>
</html>